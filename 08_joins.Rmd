---
title: "Joining & Pivoting Data"
description: | 
  How to merge your data!
output: 
  distill::distill_article:
    toc: true
---

```{r setup, include=FALSE, purl=FALSE, message=FALSE}

library(knitr)
library(here)
suppressPackageStartupMessages(library(tidyverse))

```

:::obj

**Joining and Pivoting Data**
 
 - Understand different types of joins and how to use them
 - Understand how to join datasets by shared data columns
 - Learn about the variety of join types
 - Learn what `wide` and `long` data are, and how to *`pivot`* between them

:::

## Joining Data

We often need to take several datasets and merge them into a single dataset that we can use for analysis. This "**join**" can at times be tricky, and can be made more so if we aren't exactly sure what data matches up between the two datasets, or if it's named differently in each dataframe. Sometimes joining data can resemble more of a gridlock than a clean and seamless merge.

(ref:gridlockWiki) Merging Data? *(source Wikipedia Commons)*

<center>
```{r gridlock, echo=FALSE, fig.cap="(ref:gridlockWiki)", out.height="50%"}

# "https://upload.wikimedia.org/wikipedia/commons/8/82/New_York_City_Gridlock.jpg"

knitr::include_graphics("images/New_York_City_Gridlock.jpeg")

```
</center>

### Common Variables

The trick that makes this all possible, is having one or more shared variables across each dataset. This may be an ID column, or a specific data type. Importantly, these data can actually have different column names, but typically each needs to have the same type of data (i.e., `character` and `character`) and some shared observations across each dataset in order to **join** the datasets.

While this may seem daunting at first, it's not! R has some excellent tools built into the **`{dplyr}`** package that make joining datasets fairly straightforward. First let's import some data we can use to join. Here we will build off of the datasets we used in the [previous modules](07_dplyr.html). 

First let's load the libraries and data we'll be using. We'll be continuing to use some groundwater data as shown in previous modules, a data frame of **`stations`**, **`measurements`** through time, and **`perforations`**. We'll also *join* these data to the [CalEnviroscreen dataset](https://oehha.ca.gov/calenviroscreen) which "*identifies California communities by census tract that are disproportionately burdened by, and vulnerable to, multiple sources of pollution*". One of the most notable uses of the CalEnviroscreen dataset has been to inform CalEPA’s identification of disadvantaged communities. We'll be using CalEnviroscreen v3.0 in the code that follows.

```{r libraries, eval=TRUE, echo=TRUE, messages=FALSE}

library(tidyverse)

# GW stations data
gw_stations <- read_csv("data/gwl/stations.csv")

# GW measurements data for Sac, El Dorado, Placer Counties
gw_measurements <- read_csv("data/gwl/measurements_sep.csv")

# GW depths
gw_perf <- read_csv("data/gwl/perforations.csv")

# CalEnviroscreen Data
calenviro <- read_csv("data/calenviroscreen/ces3results_data.csv")

```

<br>

:::challenge

<font color="#009E73">**Challenge 1: Find the Commonalities**</font> 

 - Look at the 3 different groundwater datasets (`gw_measurments`, `gw_perf`, and `gw_stations`) and find potential common columns/variables we can use to join. How many are there?
 
:::

<br>

<details>
  <summary class="challenge-ans-title">**Click for Answers!**</summary>
  <div class="challenge-ans-body">

There are many ways to view our data. We want to not only know the column names, but also what kind of data exists in each. What common columns can we use?

 - **`SITE_CODE`** and **`STN_ID`** is in each of the `gw_measurments`, `gw_perf`, and `gw_stations` datasets.
 
A great package to use for cleaning and checking things like this is the {[`janitor`](http://sfirke.github.io/janitor/)} package. We can use the `compare_df_cols` function to find out what data types exist across the dataframes we want to potentially join.

```{r commonCols, echo=TRUE}

library(janitor)
# tells us the column class in each dataframe, NA's for non-existent cols
compare_df_cols(gw_stations, gw_perf, gw_measurements)

# note SITE_CODE and STN_ID both exist across all 3 datasets


```

  </div>
</details> 


### Same Data, Different Names

Now we'd like to know if there are similar data columns between the groundwater datasets and the CalEnviroscreen data. To do this let's inspect our `stations` and `calenviro` data with either `head` or `names` or `str`. All will tell us similar information. At this point, we know we can tie the groundwater data together, but we need to find something to crosswalk or join the CalEnviroscreen data to the groundwater data. In this case, the CalEnviroscreen data are at a census tract level, and contain data with ZIP codes, counties, and census tracts.

(ref:AHmeetdata) *Artwork by @allison_horst*

```{r AHmeetData, echo=FALSE, out.width="80%", fig.cap="(ref:AHmeetdata)"}

include_graphics("https://raw.githubusercontent.com/allisonhorst/stats-illustrations/master/make-your-own-stats-cartoons/ex_2.png")

```

There are a lot of variables in the CalEnviroscreen dataset, so we're only showing the first 10 here.

```{r inspect, eval=T, echo=T}

names(calenviro) %>% head(10)
names(gw_stations)

```

What do we see? Looks like we have county names in both of these datasets, but they have different column names (*`COUNTY_NAME`* in `stations` and the *`California County`* column in `calenviro`. So we know we can join our three groundwater datasets together, and we know we can join the CalEnviroscreen data with the `stations` dataset by county. Let's talk about the types of joins we may use now!


## Join Types

There are quite a few different join types that are available via the **{dplyr}** package. Here are some great animations by [Garrick Aden-Buie](https://www.garrickadenbuie.com/project/tidyexplain/#usage) that may help illustrate the various join types. 

### **Left Join**

All rows from `x`, and all columns from `x` and `y`. Rows in `x` with no match in `y` will have `NA` values in the new columns. Probably one of the most common joins, where we want to keep *everything* from our first dataframe (`x`), and anything that matches `x` from the second dataframe (`y`).

```{r leftjoin, echo=FALSE, out.width='70%'}

include_graphics("images/left-join.gif")

```

### **Inner Join**

The matching join, returns all rows from `x` where there are matching values in `y`, and all columns from `x` and `y`.

```{r innerjoin, echo=FALSE, out.width='70%'}

include_graphics("images/inner-join.gif")

```


### **Full Join**

All rows and all columns from both `x` and `y`. Where there are not matching values, returns `NA` for the one missing. This is a full merge, where no data is lost from either dataset, and any non-matching data gets an `NA`.

```{r fulljoin, echo=FALSE, out.width='70%'}

include_graphics("images/full-join.gif")

```

### **Semi Join**

All rows from `x` where there are matching values in `y`, keeping just columns from `x`. Also known as a *filtering* join because you are basically filtering one dataframe, using another dataframe as the match. This can be useful when you don't actually want to join with data, but you do want to subset the data to match observations in another dataset.

```{r semijoin, echo=FALSE, out.width='70%'}

include_graphics("images/semi-join.gif")

```


### **Anti Join**

Also a *filtering join*. This keeps all rows from `x` where there are not matching values in `y`, keeping just columns from `x`. Really handy to find out which data is **not** joining, or may be missing from one or both datasets. Note, the dataframe you put first does matter...so if you switch `x` and `y` you can get different answers.

```{r antijoin, echo=FALSE, out.width='70%'}

include_graphics("images/anti-join.gif")

```


```{r, eval=F, echo=F}
# join animations with tidyexplain: https://www.garrickadenbuie.com/project/tidyexplain/
# code here: https://github.com/gadenbuie/tidyexplain/tree/master/R
# animations here:
# https://github.com/gadenbuie/tidyexplain/tree/master/images

```


## Join Our Data

For our purposes, let's assume we have some data (our CSCI data: `csci_clean`) that we want to make a map of to visualize things. But the site information (`sites_clean`) is in a separate dataframe or file! This happens all the time. Databases keep different tables, and to avoid redundancy in data, there may be one table that just has site location information and maybe a description of each site, and a table where the actual data collected at the site lives. 

Let's join our site table with our CSCI table to make a single dataset that contains both the scores for our bioassessment data, and our site localities. This will help us plot and map the data later. Remember to keep track of how many rows and columns we have in each of our datasets.

Let's use an `inner_join()` here, because we only want to keep sites that have matching Site ID codes between the CSCI data and the Sites data. If the *join* column (our Site ID) is named the exact same in each table, this is easy. We could use something like this:

```{r innerJoinSame, eval = FALSE, echo=TRUE}

# load dplyr package
library(dplyr)

# join data by common column: same name
csci_sites_match <- inner_join(csci_clean, sites_clean)

```
    
```
Error: `by` must be supplied when `x` and `y` have no common variables.
ℹ use by = character()` to perform a cross-join.
Run `rlang::last_error()` to see where the error occurred.
```

Uh-oh. But look! This error message is pretty descriptive, it tells us the two pieces we are working with (x=`csci_clean` and y=`sites_clean`) don't have a common column name (or `variable`). Then it gives us a suggestion, `use by = character()`. Let's try that and see what it looks like!

```{r innerJoinDiff, eval=FALSE, echo=TRUE, warning=FALSE}

# join data by common column: different name
csci_sites_match <- inner_join(csci_clean, sites_clean,
                               # now the by, remember x col first, then y
                               by=c("StationCode"="StationID"))

# now we have lat and lon in our dataframe with the data!
str(csci_sites_match)

```

<br>

Great! But what about the site that **didn't** join? What if we want to find out which one it was, so we can figure out why, or go collect data there?
<br>

 > **The Anti Join**

Let's use an Anti-join and quickly look at the sites that didn't match. Notice, `sites_clean` has the extra record, so we need to list it first and figure out what was missing. 

```{r antiJoin, echo=T, eval=F}

anti_join(sites_clean, csci_clean,
          by=c("StationID"="StationCode"))

```


Notice we had to list both `sites_clean` first, as well as the `sites_clean` stationID column first. 

<br>

:::challenge

**Challenge 2**

 - If we switched the objects we used in the `anti_join` (as above in the original `inner_join`), R would return zero records. Why? 

:::

<br>

<details>
  <summary class="challenge-ans-title">**Click for Answers!**</summary>
  <div class="challenge-ans-body">
  
  Because the `csci_clean` has `1612` records, and the `sites_clean` has `1613` records, and *all* the csci records joined when we used the `inner_join`, there are no records in `csci_clean` that didn't join with the `sites_clean`. So R will return zero records!
  
  </div>
</details>

<br>

## Save it Out!

Remember how to do this? Let's save this as a `.RData` file for now.

```{r saveOut, echo=T, eval=F}

# list our data object, and then the filepath and name
# remember to use a relative path!
save(csci_sites_match, file = "data/csci_sites_match.rda")

```


Great work! Let's [move to the next lesson](m2_3_using_sf.html).
