---
title: "Project Management & Data Organization"
description: | 
  Approaches towards organization and efficiency.
output: 
  distill::distill_article:
    toc: true
---

```{r setup, include=FALSE, purl=FALSE, message=FALSE}

library(knitr)

```

::: {.obj}
**Learning objectives**

-   Implement best practices for reproducible data science\
-   Create and use an RStudio project (.RProj)\
-   Understand filepaths and `{here}`\
-   Understand how and when to modify `.RProfile` and `.Renviron` files
-   Apply strategies to organize functions and scripts
-   Understand package environments and how to manage them with `{renv}`
:::

## First principles

The first step in any data science project is to set up and maintain a clean, predictable development environment. As you accumulate raw data, write code, and generate results, things can get messy. In this module we'll cover how to keep your projects organized, streamlined, and reproducible.

:::challenge

<font color="#009E73">**REVIEW**</font> 

- **Although this is an intermediate level course, we will revisit [[introductory material on "Project Management"]{style="color: #009e73"}](../intro/m_project_management.html) because no matter your skill level in R, strategic project management remains fundamental.** Subsequent modules in this course assume familiarity with `{here}`, `.Rproject`s, naming conventions, and general best practices. 

:::

<br>

After reviewing core introductory topics, we will discuss `.RProfile` and `.Renviron` files and when to use them.

# .RProfile

If you have user- or project-level **code** that needs to be run every time you start up R, `.RProfile` can streamline this operation.

The `.RProfile` file is an actual (hidden) file that is automatically sourced as `R` code when you open an `R` session. A `.RProfile` file can live in the project root directory, or the user's home directory, although only one `.RProfile` can be loaded. If a project-level `.Rprofile` exists, it supersedes the user-level `.Rprofile`.

<aside>

You can also "show hidden files" (instructions for [Mac](https://www.macworld.co.uk/how-to/show-hidden-files-mac-3520878/) and [PC](https://support.microsoft.com/en-us/windows/show-hidden-files-0320fe58-0117-fd59-6851-9b7f9840fdb2)) and edit `.RProfile` in a text editor. You can also do so in `R` with `file.edit("~/.RProfile")`.

</aside>

The easiest and most consistent way to edit your `.RProfile` file across operating systems is with the `{usethis}` package. Run `usethis::edit_r_profile()` to opens your user-level `.RProfile`.

```{r usethis-rprofile, eval = FALSE}
usethis::edit_r_profile()
```

You can edit the project-level `.RProfile` with the `scope` argument.

```{r usethis-rprofile2, eval = FALSE}
usethis::edit_r_profile(scope = "project")
```


To illustrate how `.RProfile` works, let's do something cool and useless. We'll write a short program that greets us with a random inspirational quote, and then we'll put in `.RProfile` so it runs whenever we start up R.

The [`{cowsay}`](https://cran.r-project.org/web/packages/cowsay/vignettes/cowsay_tutorial.html) package is a fun way to print text animal art. 

```{r cowsay}
cowsay::say(what = "hello world!", by = "cow")
```

Let's randomize the animal displayed and make the message it says one of the motivational quotes found at this [Github repo](https://gist.github.com/JakubPetriska/060958fd744ca34f099e947cd080b540), copy and paste the code into our `.RProfile`, and restart R.

```{r cowsay2, eval = FALSE}
animals <- names(cowsay::animals)
quotes  <- readr::read_csv("https://gist.githubusercontent.com/JakubPetriska/060958fd744ca34f099e947cd080b540/raw/963b5a9355f04741239407320ac973a6096cd7b6/quotes.csv")  
quotes$full_quote  <- paste0(quotes$Quote, " -", quotes$Author)
cowsay::say(sample(quotes$full_quote, 1), by = sample(animals, 1))
rm(animals, quotes) # remove the objects we just created
```


# .Renviron

Sometimes you need to store sensitive information, like API Keys, Database passwords, data storage paths, or general variables used across all scripts. We don't want to accidentally share these information, accidentally push them to Github, or copy and paste them over and over again from script to script. We also might want to build a codebase that relies on a few variables that another user can set in their own system in a way that works for them. Environmental variables are the way to address all of these concerns.

Environmental variables are simply objects that store character strings. They are accessible from within R upon startup. To view all environmental variables, use `Sys.getenv()`. You can also pull out one environmental variable at a time by passing in its name, for instance:

```{r getenv}

Sys.getenv("USER")

```

You can set your own environmental variables which are stored in another hidden file called `.Renviron` (this is the Python analog of `.env`). 

To illustrate the use of `.Renviron`, we run `usethis::edit_r_environ()`, add the environmental variable `ANIMAL = "cat"`, save, and restart `R`.

```{r usethis-renviron}
usethis::edit_r_environ()
```

We can access our environmental variable (remember you need to restart R for changes to take effect) as follows:

```{r usethis-renviron2}
Sys.getenv("ANIMAL")
```

We can use our environmental variable, for instance, in a function.

```{r cowsay-function}
inspire_me <- function(animal){
  
  suppressMessages(
    quotes  <- readr::read_csv("https://gist.githubusercontent.com/JakubPetriska/060958fd744ca34f099e947cd080b540/raw/963b5a9355f04741239407320ac973a6096cd7b6/quotes.csv")  
  )
  quotes$full_quote  <- paste0(quotes$Quote, " -", quotes$Author)
  cowsay::say(sample(quotes$full_quote, 1), by = animal)

}

inspire_me(Sys.getenv("ANIMAL"))
```

Although it may not appear powerful in this trivial example, when a project grows substantially large and complex, or when managing multiple sensitive passwords and access tokens, environmental variables should be what you reach for.


# Strategies to organize projects

Best practices for writing code across languages typically recommend package imports and function definitions at the top of a script, followed by code. For example:  

```{r org-ex, eval = FALSE}
# import packages
library(package_1)
library(package_2)

# define functions
my_first_function <- function(){
  print("hello")
}

my_second_function <- function(){
  print("world")
}

# code
my_first_function()
my_second_function()
```

These approaches work well when scripts are relatively simple, but as a project grows large and complex, it's best practice to abstract functions into another script or set of scripts, and break up your workflow into discrete steps.

For instance, although the `inspire_me()` function above is relatively simple, we can pretend that the read, transform, and print steps carried out in the function were themselves long functions in part of a much more complex, real-world workflow. Imagine we created a script called `functions.R` that contained the following code:

<aside>
Notice that all functions start with `f_`. This prefix makes it easy to read in a script and takes advantage of auto-complete.
</aside>

```{r functions-r, eval = FALSE}
# list packages in a vector and load them all
pkgs <- c("readr", "cowsay")
purrr::walk(pkgs, require, character.only = TRUE)

# read quotes from a url
f_read_data <- function(url){
  suppressMessages(
    quotes  <- read_csv(url)  
  )
  return(quotes)
}

# paste the quote to the author
f_preprocess_data <- function(d){
  d$full_quote  <- paste0(d$Quote, " -", d$Author)
  return(d)
}

# print a random animal and a random quote
f_inspire_me <- function(d){
  animals <- names(animals)
  say(sample(d$full_quote, 1), by = sample(animals, 1))
}
```

We can call this script using `source()` to bring the functions into our environment.

```{r source, eval = FALSE}

source(here("functions.R"))

```


However, this is hardly a satisfying solution because in a real project, our pretend functions above may grow quite large, and we will likely add more and more functions, such that script that holds them all, `functions.R` may become many hundreds of lines long, making it difficult to sift through and make debug or add new lines of code. Let's now move these functions to a directory `/functions` and store them all as separate files named after their function name:

<aside>
A good rule of thumb to follow is to try and keep scripts less than 150 lines in length. When scripts approach this length, they become difficult to keep track of, and there were likely missed opportunities to refactor the script into separate functions and modules.
</aside>

Save as `/functions/f_read_data.R`

```{r functions-r-1, eval = FALSE}

# read quotes from a url
f_read_data <- function(url){
  suppressMessages(
    quotes  <- read_csv(url)
  )
  return(quotes)
}
```

Save as `/functions/f_preprocess_data.R`

```{r functions-r-2, eval = FALSE}
# paste the quote to the author
f_preprocess_data <- function(d){
  d$full_quote  <- paste0(d$Quote, " -", d$Author)
  return(d)
}
```

Save as `/functions/f_inspire_me.R`

```{r functions-r-3, eval = FALSE}
# print a random animal and a random quote
f_inspire_me <- function(d){
  animals <- names(animals)
  say(sample(d$full_quote, 1), by = sample(animals, 1))
}
```

The `functions` folder in the root project directory should now look like this:

```{r function-img, echo = FALSE}
knitr::include_graphics(here::here("images","function_img.png"))
```


Now in our `/code` directory, we create a script, `01_control.R` to source our functions and use them. Be sure to restart `R` to clear your environment before sourcing this control script.

Save as `/code/01_control.R` and run.

```{r source-functions-in-folder}
# packages needed for this script
pkgs <- c("readr", "cowsay", "here", "tidyverse")
purrr::walk(pkgs, require, character.only = TRUE)

# silently source all functions
walk(list.files(here("functions"), full.names = TRUE), ~source(.x))

# define the url where quotes are located
url <- "https://gist.githubusercontent.com/JakubPetriska/060958fd744ca34f099e947cd080b540/raw/963b5a9355f04741239407320ac973a6096cd7b6/quotes.csv"

# use all of our functions
f_read_data(url) %>% 
  f_preprocess_data() %>% 
  f_inspire_me()
```

`source()` is the key to chaining together many scripts. In the example above, we were able to abstract functions into a separate folder which makes keeping track of them much easier than if they cluttered our control script. 

<aside>
It's also a good rule of thumb to keep each line of code less than 75 characters long to ease readability.
</aside>

:::challenge

<font color="#009E73">**Learn more**</font> 

Separating all functions into standalone scripts is not a revolutionary idea -- in fact, this is precisely how R packages are written! For example, see the [`{dplyr}` github repo's /R folder](https://github.com/tidyverse/dplyr/tree/master/R) which contains all dplyr functions in one directory. When you call `library(dplyr)` you're essentially sourcing all of these functions into your environment. 

If project management and reproducible data pipelines are interesting to you, check out the [`{drake}` R package](https://github.com/ropensci/drake). A similar framework for Shiny Apps exists called [`{golem}`](https://thinkr-open.github.io/golem/), which also includes `{usethis}`-like commands that streamline common chores in Shiny App development. 

:::


# renv

We use `{here}` because we expect that whoever else opens your code on their machine is likely to have a different project root path, and `{here}` ensures your code is portable between different computers with different root project paths (e.g., `~/Documents/Github/myproject` v `C:\Users\louis\Documents\myproject`).

Development environments are similar. When we work in `R` -- or any programming language for that matter -- we use a snapshot of package versions based on when we downloaded and installed them [e.g. with `install.packages()`]. You can check the version of the installed packages loaded into your current environment with `sessionInfo()`.

```{r sessionInfo}
sessionInfo()
```

The version number is the string of numbers listed after a package name and underscore.  

Similarly, you can use `installed.packages()` to view information on all of your installed packages.

When packages change between versions, changes are typically designed to fix bugs or improve performance, but sometimes, they can break code. Thus, collaborative work on a project may be challenged by people working on the same code but with different versions of packages.

<aside>
Even the version of R itself changes, although base R changes very slowly and the R Core Team tries to make new versions of R backwards-compatible to not break scripts written before potentially breaking changes.
</aside>

The solution to this problem is for everyone to use the same versions of packages (and `R`), which is to say that collaborators should use the same ***development environment***. This is a common concept across programming languages.

[`{renv}`](https://rstudio.github.io/renv/articles/renv.html) manages your package environment and makes it easy to share it with others by creating and curating a "lock" file (`renv.lock`) in the root project directory. When starting a project, create the file with `renv::init()`, install packages as you go along, and update the lockfile with `renv::snapshot()`. When a collaborator opens your project (for example, after cloning it from Github), all they need to do is open the `.RProj` file and `{renv}` will bootstrap itself and set up the development environment captured in the lock file. 

<aside>
The `renv.lock` file is a JSON file with information on the version of R and the versions of all packages used by the project.
</aside>

If you find yourself needing to share important analyses, perhaps that run on a production server, you should look into `{renv}`. For most day-to-day data science that you don't plan on sharing or working collaboratively on, it may be unnecessary. 
