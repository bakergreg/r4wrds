---
title: "Variable Storage & Data Structures"
description: | 
  The building blocks of data science in R
output: 
  distill::distill_article:
    toc: true
---

```{r setup, include=FALSE, purl=FALSE, message=FALSE}

library(knitr)

```

:::obj

**Learning objectives**
 
 - Assigning objects
 - Know basic object classes (logical, numeric, factor, character)  
 - Understand basic R data structures (vectors, lists, data.frames)
 - Know properties of R data structures and how to interact with them
 - Know how to spot and deal with missing values (`NA`)

:::

## Assignment

R is an object oriented programming language, which means that it is oriented around objects which can be data (e.g., data.frames, vectors, lists) or code (e.g., functions). We've already been using assignment to create variables, or objects. In the previous lesson, we read in csv files and **assigned** them to a variable using the assignment operator, `<-` (RStudio shortcut: `Alt` + `-`). Avoid using `=` for assignment which will also work but cause confusion later ([here's a blog post on the history behind `<-`](https://colinfay.me/r-assignment/)). 

When assigning an object, avoid overly simplistic names (e.g., `x`, `y`), and rather, pick concise names that describes the object and improve code interpretability. Let's read in our groundwater level station data and *assign* it to the variable name `stations`.

```{r assignment-data}
library(readr)
library(here)

# read the stations.csv file and assign it to an object "stations"
stations <- read_csv(here("data", "gwl", "stations.csv"))
```

Now let's define a function that takes a data.frame and returns a vector of column classes, and assign it to the object `get_column_classes`. Don't worry about how we created a function here -- there's an entire [module on functions]() coming up. We only define a custom function to illustrate that code, like data, is represented as a object in R.  

```{r assignment-code}
# function that reports the class of each column of an input dataframe
get_column_classes <- function(df){
  col_classes <- sapply(df, class)
  return(col_classes)
}

# run the function to see the output
get_column_classes(stations)
```

Notice that in the Global Environment pane, under the heading "Data" we find the object `stations` and under the heading "Functions" we find the custom function `get_column_classes()`.


## Basic object classes

Every object in R has a `class` property, and each property defines what functions will work on it. Many bugs result from functions applied to the wrong object class, so it's important to know how to check the class of an object and figure out what functions can be applied to it. 

There are more base object classes in R, like matrices and arrays, but in this course we will focus on vectors, and devote most of our attention to a special type of list called the `data.frame` or `tibble`.  

Let's check the class of the objects we created above with the `class()` function:

```{r class-data}
class(stations)
```

`stations` has 4 classes, and we can see that it is a `tbl` of three types, and a `data.frame`. What's the class of the function we defined earlier?  

```{r class-code}
class(get_column_classes)
class(mean)
```

As expected, `get_column_classes` is a function, just like other built-in functions, like `mean()`. What class is the result of `get_column_classes`?

```{r class-vector}
class( get_column_classes(stations) )
```

The class of this output is a **vector** of type `character`. A **vector** where every entry (think row) in that object is the **same type** is called an **atomic vector** because each part of the vector is the same. This character vector is an **atomic vector**.  

There are 4 major classes of atomic vectors, arranged below in order of complexity.  

* logical (`TRUE`, `FALSE`)  
* numeric (contains both integer and double, but we will only cover double)  
* factor (categorical and ordinal variables)  
* character (strings)  

Use the `c()` (**concatenate**) function to create vectors. Let's use `c()` to create each of these 4 vector classes for an imaginary data set of river reaches.  

```{r c}

# logical: is the river dry at the time of measurement
dry <- c(TRUE, FALSE, FALSE)

# flow measured at each reach in cfs
flow <- c(0, 57, 128)

# month the measurement was taken
date <- factor(c("July", "January", "February"), levels = month.name)

# reach name
reach <- c("Dry Creek", "Raging Waters", "Wild Rapids")

```


Each vector above has **3 entries**, also called **elements**. We can check the class of each of these vectors:

```{r vectors-check-classes}

class(dry)
class(flow)
class(date)
class(reach)

```

### logical (boolean)

Logical vectors (also called booleans) are the most simple type of atomic vectors, and can take one of three values: `TRUE`, `FALSE`, or `NA`. Logical vectors are output as the result of logical tests.

```{r logical-test}

# Is the character string "Merced River" in the character vector "reach"?
"Merced River" %in% reach

# Is the character string "Raging Waters" in the character vector "reach"?
"Raging Waters" %in% reach

```


### numeric

Imagine you wanted to transform the numeric flow data you have from cubic feet per second (cfs) to gallon per minute (gpm). R is a "vectorized" language and allows transformations to an entire vector with relative ease.

```{r numeric-vectorized}

# convert each element of "flow" from cfs to gpm by multiplying by 448.83
flow_gpm <- flow * 448.83

# print the result
flow_gpm

```


### factor

If our factor variable `month` was an ordinary character vector, it would not sort meaningfully.

```{r factor-sort}

date_character <- c("July", "January", "February")
sort( date_character )

```

The above is out of order, but if we define the **levels** that these ordinal variables should follow, we can store the vector as a factor and get meaningful sorting behavior.

```{r factor-sort-2}

# create a factor by specifying the levels (order) of the variable
date <- factor(c("July", "January", "February"), levels = month.name)
sort(date)

```

### character (string)

Character vectors can store arbitrary strings. There are many ways to work with strings from [basic string manipulation](https://r4ds.had.co.nz/strings.html), all the way to [natural language processing](https://www.tidytextmining.com/) that we don't have time to cover in this course, but you should know that they exist. 

Create strings by enclosing them with quotation marks. It doesn't matter if you use single or double quotes, just be sure to use the same quote style for a single character string!  

```{r char-quote}

# create a character vector of length 1 using single quotes
hello <- 'Why helloooo'

# create a character vector of length 2 using double quotes
instructors <- c("Rich", "Ryan")

# paste the vectors together
paste(hello, instructors)

```

Notice that when we pasted together a vector of length 1 with a vector of length 2, we got an output character vector of length 2. This concept is called "recycling" (because the shorter length vector was used twice, or recycled) and will come back later in this module.  


:::challenge

<font color="#009E73">**Challenge 1**</font> 

1. Create an character vector called `meals` and assign it a string with what you plan to have for for breakfast, lunch, and dinner today.  
2. Create a numeric vector called `cost` with the approximate cost in dollars of each meal.  
3. Calculate the cost each meal if you ate that and only that for 365 days a year (Hint: multiply `cost` by 365, then take the `sum()`).  
4. **Bonus**: Paste together a string that announces this cost.  

:::

<br>

<details>
  <summary class="challenge-ans-title"><font color="#0072B2">**Click for Answers!**</font></summary>
  <div class="challenge-ans-body">

```{r challenge-1}
# create a string of three meals
meals <- c("eggs, toast and coffee", "pizza", "tacos and salad")

# cost of each meal in dollars
cost <- c(2.25, 5.50, 8.95)

# annual cost
annual_cost <- cost * 365
sum(annual_cost)

# bonus
paste("It costs", sum(annual_cost), "per year to feed a Rich.")
```

  </div>
</details>



## Basic data structures

Vectors are the building blocks of more useful data structures, especially the `data.frame` and `tibble` that will be the focus of subsequent modules. 

### vector

Above, we covered atomic vectors, which have one and only one class (logical, factor, numeric, character). All vectors have a property called `length`.

```{r vector-length}

length(reach)
length(flow)

```


### list

A special type of non-atomic vector called the `list` can contain many different types of data. Lists can contain any types of data structures, even other lists!

```{r list}

l <- list(reach, stations, "a random string")
length(l)

```

We can access list elements with double bracket notation `[[`. 

```{r list-access}

# access first element of the list
l[[1]]

# access second element
l[[2]]

# access third element
l[[3]]

```


### data.frame and tibble

Sometimes called "list-columns", the `data.frame` is perhaps the most common form of data you will encounter in R, and the focus of almost all remaining modules in the course. The `data.frame` is a set of named vectors arranged as columns. 

Let's use the vectors we created earlier to make a `data.frame` called `riv`.  

```{r dataframe}

riv <- data.frame(reach, date, dry, flow)

riv
```

We can access any column from the data frame as a vector using the `$` notation. In RStudio, typing `$` also brings up an auto-complete, and we can see all of the columns in the `data.frame`.

```{r df-dollar-sign}

riv$reach
riv$flow

```

We can also use `$` to remove a column if we assign an existing column to a value of `NULL`, or add a **new column** by entering a new column name not already present, and assigning it a value.  

```{r df-rm-col}

# remove the "Reach" column
riv$reach <- NULL
riv

```


```{r df-add-col}

# Add the reach column back, but called "reach_name" this time
riv$reach_name <- reach
riv

```

When we assign a vector to a `data.frame` as a new column, and that vector is not as long as the number of rows in the data, but its length is a multiple of the number of rows the `data.frame`, R "recycles" the vector.

```{r df-recycling, eval = FALSE}

# add a vector "tech" for the "field technician" to be recycled
tech <- c("Rich", "Ryan")
riv$tech <- tech

```

Uh oh! This won't work because the length of the vector we attempted to add (2) to the `data.frame` isn't equal to, or a multiple of, the number of rows (3).

```{r df-recycling-2}

nrow(riv) == length(tech)

```

However, if we add a vector to the `data.frame` with length 1 (which is a multiple of 3):  

```{r, df-recycling-3}

riv$tech <- "Rich"
riv

```

R **recycles** the string "Rich", repeating it 3 times. This is convenient, but can also lead to silent bugs, so we advise using the `tibble` instead of the `data.frame`.

The `tibble` is a modern `data.frame` with stricter recycling rules, R-friendly print behavior (prints only the first 10 rows and shows column types), and a [few more features](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html) that make them more predictable and less likely to lead to bugs.

Earlier, when we read `stations` with `read_csv()` it was read as a tibble, which we can verify with `class(stations)`. Convert `stations` to a `data.frame` and print it to console by running `data.frame(stations)`. 

```{r, df-stations}
stations_df <- data.frame(stations)
class(stations_df)
```

`tibble`s are essentially spreadsheets in R, flat, 2D rectangular data made of rows and columns. We can check the number of rows and columns in a `tibble`. 

```{r df-dim}

dim(stations)
nrow(stations)
ncol(stations)

```

A `tibble` combines lists into columns, so its length is the same as its number of columns.  

```{r, df-length}

length(stations) 

```


:::challenge

<font color="#009E73">**Challenge 2**</font> 

1. Extract the "LATITUDE" column from `stations`, assign it to a variable called `lat`, and calculate the mean latitude.  
2. Assign a column to `riv` called "depth" with values 1, 2, 3. 
3. Assign another column called "width" with values 10, 10, 10. Take advantage of recycling when creating the "width" column.  
4. Assign a new variable called "area" to `riv` which is the product of "depth" and "width" (Hint: `riv$depth * riv$width`).  

:::

<br>

<details>
  <summary class="challenge-ans-title"><font color="#0072B2">**Click for Answers!**</font></summary>
  <div class="challenge-ans-body">

```{r challenge-2}
# extract LATITUDE and calculate the mean value
lat <- stations$LATITUDE
mean(lat)

# add depth and width to riv
riv$depth <- c(1, 2, 3)
riv$width <- 10 # this vector of length 1 is recycled 

# calculate area and add it to riv
riv$area <- riv$depth * riv$width
```

  </div>
</details>


## A note on `NA`

`NA` has a special meaning in R and designates a missing value. Operations on a vector with missing values cannot return a value unless we explicitly tell R to ignore these missing values.

```{r, na}
z <- c(2, NA, 4)
mean(z)
sum(z)
```

```{r, na2}
mean(z, na.rm = TRUE)
sum(z, na.rm = TRUE)
```



*Lesson adapted from [R for Data Science](https://r4ds.had.co.nz/)*.
