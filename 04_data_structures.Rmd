---
title: "Variable Storage & Data Structures"
description: | 
  Getting to know the building blocks of data science in R
output: 
  distill::distill_article:
    toc: true
---

```{r setup, include=FALSE, purl=FALSE, message=FALSE}

library(knitr)

```

:::obj

**Learning objectives**
 
 - Assigning objects
 - Know basic object classes (logical, numeric, factor, character)  
 - Understand basic R data structures (vectors, lists, data.frames)
 - Know properties of R data structures and how to interact with them
 - Know how to spot and deal with missing values (`NA`)

:::

## Assignment

R is an object oriented programming language, which means that it is oriented around objects which can be data (e.g., data.frames, vectors, lists) or code (e.g., functions). We've actually been using assignment already to create variables, or objects. In the previous lesson, we read in csv files and assigned them to a variable using the assignment operator `<-` (shortcut: `Alt` + `-`). Avoid using `=`, which will also work but cause confusion later ([here's a blog post on the history behind `<-` for later](https://colinfay.me/r-assignment/)). 

When assigning an object, avoid overly simplistic names (e.g., `x`, `y`), and rather, pick concise names that describes the object and improve code interpretability. Let's read in our groundwater level station data and *assign* it to the variable name `stations`.

```{r assignment-data}
library(readr)
library(here)

# read the stations.csv file and assign it to an object "stations"
stations <- read_csv(here("data", "gwl", "stations.csv"))
```

Now let's define a function that takes a data.frame and returns a vector of column classes, and assign it to the object `get_column_classes`.  

```{r assignment-code}
# function that reports the class of each column of an input dataframe
get_column_classes <- function(df){
  col_classes <- sapply(df, class)
  return(col_classes)
}

# run the function to see the output
get_column_classes(stations)
```

Don't worry about how we created a function here -- there's an entire [module on functions]() coming up. We only define a custom function to illustrate that code, like dat, is represented as a object in R. Notice that in the Global Environment pane, we have "Data" including the object `stations` and "Functions" containing the custom function `get_column_classes()`.


## Basic object classes

Every object in R has a `class` property, and each property defines what functions will work on it. Understanding how to check the class of an object and figure out what functions can be applied to what object classes is paramount. Many bugs are the result of functions applied to the wrong object class.

Let's check the class of the objects we created above:

```{r class-data}
class(stations)
```

```{r class-code}
class(get_column_classes)
```

As expected, `stations` is a data.frame, and `get_column_classes` is a function. What about the result of `get_column_classes`?

```{r class-vector}
class( get_column_classes(stations) )
```

The class of this output is a vector of type `character`. A **vector** is an object where every entry (think row) in that object is the **same type**. Sometimes, these are called **atomic vectors** because each part of the vector is the same.

There are 4 major classes of vectors, arranged in order of complexity:

* logical (`TRUE`, `FALSE`)  
* numeric (contains both integer and double, but we will only cover double)  
* factor (categorical and ordinal variables)  
* character (strings)  

Use the `c()` (**concatenate**) function to create vectors. Let's use `c()` to create each of these 4 vector classes for an imaginary data set of river reaches.  

```{r c}

# logical: is the river dry or not at the time of measurement
dry <- c(TRUE, FALSE, FALSE)

# flow measured at each reach in cfs
flow <- c(0, 57, 128)

# month the measurement was taken
date <- factor(c("July", "January", "February"), levels = month.name)

# reach name
reach <- c("Dry Creek", "Raging Waters", "Wild Rapids")

```


Each vector above has **3 entries**, also called **elements**. We can check the class of each of these vectors:

```{r vectors-check-classes}

class(dry)
class(flow)
class(date)
class(reach)

```

### logical (boolean)

Logical vectors (also called booleans) are the most simple type of atomic vectors, and can take one of three values: `TRUE`, `FALSE`, or `NA`. They can be output as the result of logical tests.

```{r logical-test}

# Is the character string "Merced River" in the character vector "reach"?
"Merced River" %in% reach

# Is the character string "Raging Waters" in the character vector "reach"?
"Raging Waters" %in% reach

```


### numeric

Imagine you wanted to transform the numeric flow data you have from cubic feet per second (cfs) to gallong per minute (gpm). R is a "vectorized" language and allows transformations to an entire vector with relative ease.

```{r numeric-vectorized}

# convert each element of "flow" from csf to gpm by multiplying by 448.83
flow * 448.83

```


### factor

If our factor variable `month` was an ordinary character vector, it would not sort meaningfully.

```{r factor-sort}

sort( c("July", "January", "February") )

```

The above is out of order, but if we define the **levels** that these ordinal variables should follow, we can store the vector as a factor and get meaningful sorting behavior.

```{r factor-sort-2}

sort(date)

```

### character (string)

Characters vectors are flexible and can store strings of any length. There are many ways to work with strings from [basic string manipulation](https://r4ds.had.co.nz/strings.html), all the way to [natural language processing](https://www.tidytextmining.com/) that we don't have time to cover in this course.


:::challenge

<font color="#009E73">**Challenge 1**</font> 

1. Create an character vector called `meals` and assign it a string with what you plan to have for for breakfast, lunch, and dinner today.  
2. Create a numeric vector called `cost` with the approximate cost in dollars of each meal.  
3. Calculate the cost each meal if you ate that and only that for 365 days a year (Hint: multiply `cost` by 365, then take the `sum()`).  

:::

<br>

<details>
  <summary class="challenge-ans-title"><font color="#0072B2">**Click for Answers!**</font></summary>
  <div class="challenge-ans-body">

```{r challenge-1}
# create a string of three meals
meals <- c("eggs, toast and coffee", "pizza", "tacos and salad")

# cost of each meal in dollars
cost <- c(2.25, 5.50, 8.95)

# annual cost
annual_cost <- cost * 365
sum(annual_cost)
```

  </div>
</details>



## Basic data structures

Vectors are the building blocks of more useful data structures, especially the `data.frame` and `tibble` that will be the focus of subsequent modules. 

### vector

Above, we covered atomic vectors, which have one and only one class (logical, factor, numeric, character). All vectors have a property of `length`.

```{r vector-length}

length(reach)
length(flow)

```


### list

A special type of non-atomic vector called the `list` can contain many different types of data. Lists can contain any types of data structures, even other lists!

```{r list}

l <- list(reach, stations, "a random string")
length(l)

```

We can access list elements with double bracket notation `[[`. 

```{r list-access}

# access first element of the list
l[[1]]

# access second element
l[[2]]

# access third element
l[[3]]

```


### data.frame and tibble

Sometimes called "list-columns", the `data.frame` is perhaps the most common form of data you will encounter in R, and the focus of most of the rest of the modules in the course. The data frame is a set of named vectors arranged as columns. 

Let's use the vectors we created earlier to make a `data.frame` called `riv`.  

```{r dataframe}

riv <- data.frame(reach, date, dry, flow)

riv
```

We can access any column from the data frame as a vector using the `$` notation. In RStudio, typing `$` also brings up an auto-complete, and we can see all of the columns in the data.frame.

```{r df-dollar-sign}

riv$reach
riv$flow

```

We can also use `$` notation to remove a column, or add a **new column**.  

```{r df-rm-col}

# remove the "Reach" column
riv$reach <- NULL
riv

```


```{r df-add-col}

# Add the reach column back, but called "reach_name" this time
riv$reach_name <- reach
riv

```

When we pass a vector to a `data.frame` with length less than and a multiple of the number of rows the `data.frame`, R "recycles" the vector.

```{r df-recycling, eval = FALSE}

# add a vector "tech" for the "field technician" to be recycled
riv$tech <- c("Rich", "Ryan")

```

Uh oh! This won't work because the length of the vector we attempted to add to the `data.frame` isn't equal to the number of rows or a multiple of the number of rows.

```{r df-recycling-2}

nrow(riv) == length(c("Rich", "Ryan"))

```

However, if we add a vector to the `data.frame` with length 1:  

```{r, df-recycling-3}

riv$tech <- "Rich"
riv

```

R **recycles** the string "Rich", repeating it 3 times. This is convenient, but can also lead to silent bugs, so we advise using the `tibble` instead of the `data.frame`.

The `tibble` is a modern `data.frame` with stricter recycling rules, R-friendly print behavior (prints only the first 10 rows and shows column types), and a [few more features](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html) that make them more predictable and less likely to lead to bugs.

When we read `stations` with `read_csv()` it was read as a tibble, which we can verify with `class(stations)`. Convert `stations` to a data.frame and print it to console by running `data.frame(stations)`. 

```{r, df-stations}
stations_df <- data.frame(stations)
class(stations_df)
```

`tibble`s have a dimension (rows and columns) which we can determine.

```{r df-dim}

dim(stations)
nrow(stations)
ncol(stations)

```

A `tibble` combines lists into columns, so its length is the same as its number of rows.

```{r, df-length}

length(stations)

```


:::challenge

<font color="#009E73">**Challenge 2**</font> 

1. Extract the "LATITUDE" column from `stations`, assign it to a variable called `lat`, and calculate the mean latitude.  
2. Add a column to `riv` called "depth" with values 1, 2, 3. Add another column called "width" with values 10, 10, 10. Take advantage of recycling.  
3. Add a new variable called "area" to `riv` which is `riv$depth * riv$width`.  

:::

<br>

<details>
  <summary class="challenge-ans-title"><font color="#0072B2">**Click for Answers!**</font></summary>
  <div class="challenge-ans-body">

```{r challenge-2}
# cextract LATITUDE and calculate the mean value
lat <- stations$LATITUDE
mean(lat)

# add depth and width to riv
riv$depth <- c(1, 2, 3)
riv$width <- 10

# calculate area and add it to riv
riv$area <- riv$depth * riv$width
```

  </div>
</details>


## A note on `NA`

`NA` has a special meaning in R and designates a missing value. Operations on a vector with missing values cannot return a value unless we explicitly tell R to ignore these missing values.

```{r, na}
z <- c(2, NA, 4)
mean(z)
sum(z)
```

```{r, na2}
mean(z, na.rm = TRUE)
sum(z, na.rm = TRUE)
```



*Lesson adapted from [R for Data Science](https://r4ds.had.co.nz/)*.
